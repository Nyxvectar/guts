/**
 * Author:  Nyxvectar Yan
 * Repo:    guths
 * Created: 07/29/2025
 */

package _struct

import "fmt"

func GutsStruct() {
	// cpu的内存使用分为地址总线和数据总线
	// 地址总线的大小决定了其内存寻址所可以到达的上限
	// 而数据总线的大小决定其内存操作所可以到达的上限
	// 内存结构的并行设计需要内存对齐,这是减少额外处理
	// 造成性能损失的必要操作.
	// 一个结构体类型的对齐边界是其中各个成员对齐值的
	// 最大对齐边界,而如果每个值是单独声明的,编译器会
	// 为她选择一个合适的对齐边界,核心目的都是为了提高
	// 性能.如下面所示,就取得float64的对齐而不是uint8:
	// 为了减少内存占用，将较大的字段放在前面
	type nyxvectar struct {
		gender float64
		grade  uint16
		age    uint8
		// 填充字节（假设系统是64位，对齐边界为8字节）
		// 这里会有5个字节的填充，使结构体总大小为16字节
	}
	// 但是不管是那种,存储时对齐的都是其所取得对
	// 齐边界的倍数.找到对齐起点以后接下来则是相对对齐.
	// 之所以要对齐倍数,可以试着将另一个结构接上来,在
	// 内存当中的直接拼接就引发了错误的内存对齐.
	// cpu不是不能跑,但是这样子就拉低了计算机性能.
	// 如此才可以保证数组中没一个都是内存对齐的.
	// 好了你肯定看懂了,对吧
	fmt.Print(nyxvectar{})
}
