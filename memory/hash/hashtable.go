/**
 * Author:  Nyxvectar Yan
 * Repo:    guths
 * Created: 07/30/2025
 */

package hash

import "fmt"

func GutsHash() {
	// 哈希表可以认为是一个大型的数组其中的元素则是
	// 一个个链表，而她们的位置值是可以计算的，这意
	// 味着哈希表不需要通过遍历、移动等方式来确定所
	// 求值的位置, 而是直接计算得到, 这是一种利用空
	// 间交换时间的做法, 提高了查找读取的效率. 她的
	// 时间复杂度是O(1)(理想情况下). 在最极端的时候
	// 如果所有的数据哈希结果都是一样的, 那么她们将
	// 进入同一个链表, 也就是桶. 此时数据的读取已经
	// 和普通链表无异, 而时间复杂度也到达了O(n).
	// 一般这种情形的类似情况时有发生, 因而需要适当
	// 地优化哈希表的算法, 以免哈希碰撞.
	// 常见的选择桶的方法有如取模法和与运算法.
	{
		// 为了解决哈希冲突, 有开放地址法, 向后遍历链表
		var hashTable1 = make([][]int, 10)
		for m := 0; m < len(hashTable1); m++ {
			hashTable1[m] = []int{m}
			fmt.Println(hashTable1[m])
			// if found {
			//     ......
			// }
		}
		// 也可以是我们刚开始提到的链表法, 形如:
		var hashTable2 = make([][]int, 10)
		for i := 0; i < len(hashTable2); i++ {
			hashTable2[i] = []int{i}
			fmt.Println(hashTable2)
		}
	}
	// 扩容是一种解决哈希冲突的办法. 为了决定是否进行扩容
	// 常常判断负载因子的值, 也就是count/m的值,  这个值表
	// 示了当前已经存在的散列值和桶的数目底比值, 可以理解
	// 为当前通的数目够不够用的判断依据.
	// 哈希表的扩容会创建新的桶, 一般不会特意去全部复制一
	// 遍值, 这耽误了业务的时间, 通常将复制到新桶和弃用旧
	// 的桶的操作分摊到许多次哈希表操作当中. 即渐进式扩容
	// 避免一次扩容操作造成的性能瞬时抖动.
}
